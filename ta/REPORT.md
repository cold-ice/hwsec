# Timing Attack

## General description

The implementation of the P function is prone to timing attacks because the code executes an operation only when the extracted bit is equal to one, hence the attacker will be able to tell fast executions from slow executions. This allows to build a model of the computation time given different input values fed to the P function. The input values of the P function can be easily retrived as the DES algorithm, like any other reliable security algorithm, doesn't rely on secrecy to grant security. In particular, to recover the input of the P function in the last round (and, by estension, in any other round, once the necessary subkeys are found), it is necesary to perform the inverse permutation of the cipher text, extract the rightmost 32 bits and perform the extended permutation on these bits. At this point it is necessary to xor the obtained 48 bits with the round key, which is obviously not available to the attacker. This is where statistical analysis comes into play, as the key may be guessed in order to retrieve the possible input of the P function.

Clearly, using a random key value, while providing a possible input for the P function, doesn't serve any purpose. Guessing the whole key is obviously not a viable option either, as 48 bits constitute a very large key space size. However, it is possible to guess 6 bits of the key at a time, as the input of the various s-boxes (whose outputs are concatenated and fed to the P function) is made up by only 6 bits of the result of the xor operation. Therefore, the simplest way to build a model for the computation is to isolate one s-box at a time, try all the 64 possible keys and record the hamming weight of the output of the s-box. If the guessed key is the correct one there exists a noticeable correlation between the overall processing time and the hamming weight of the partial result, as the larger the number of ones in the result, the slower the weak P function will be. In order to assess the degree of correlation it is necessary to perform many encryptions with different plaintexts, as the input of the s-boxes will obviously change with different plaintexts while using the same key. The model can then be built by comparing the overall processing time and the hamming weight of the output of each s-box: the larger the correlation between total processing time and hamming weight, given different plaintexts, the higher the likelihood that the guessed key is correct.

## Attack phase

The strategy described in the previous section has been implemented through the code in [ta.c](ta.c), which performs it 6 bits at a time and concatenates the various results to retrieve the overall round key. Refer to the comments inside the file itself to have an explanation of the algorithm. The attack was tested against several scenarios generated via `ta_acquisition` and always proved successful when using 100000 tests.

## Countermeasure

The file [p.c](p.c) was modified in order to remove the correlation between the overall execution time and the execution time of the P function. In order to do so, the usage of bit manipulation functions was substituted by bitwise operations. In the new version the bit specified by the P table is extracted from the input by shifting it to the rightmost position and by seting all the other bits to zero. Then, the extracted bit is shifted to the position it should occupy in the output and this temporary result is juxtaposed to the output via an OR operation, in order to update the proper bit, be it a 0 or a 1. This implementation, besides heavily reducing the average computation time, proved secure against timing attacks, since the binary obtained from [ta.c](ta.c) always computes a wrong round key when executed, regardless of the input. The file [p.c](p.c) contains as well other non vulnerable versions of the P function. Notice that they were produced because it seemed that the implementation with bitwise operations was not capable of decorrelating the total time and the P function time. This erroneous notion was due to mistakenly using a previously produced `dat` file. The other versions, although noticeably less efficient, are capable as well to remove the vulnerability.

According to my knowledge, the execution speed of bitwise operations doesn't vary appreciably by varying the input since these operations rely, in principle, on elementary standard cells, whose speed mostly depends on the technology, on the layout and on their architecture. In fact, even by trying with 1000000 tests, the `ta` binary was never able to retrieve any key. However the best solution against timing attacks is probably to employ an accurate timer and to always wait until a fixed time has elapsed before exiting the P function in order to fully standardize the execution time, regardless of the input. Clearly, the time to be waited has to be larger than the execution time for the worst case scenario.
